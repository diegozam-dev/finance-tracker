-- better-auth schemes
create table "user" ("id" text not null primary key, "name" text not null, "email" text not null unique, "emailVerified" boolean not null, "image" text, "createdAt" timestamp not null, "updatedAt" timestamp not null);

create table "session" ("id" text not null primary key, "expiresAt" timestamp not null, "token" text not null unique, "createdAt" timestamp not null, "updatedAt" timestamp not null, "ipAddress" text, "userAgent" text, "userId" text not null references "user" ("id"));

create table "account" ("id" text not null primary key, "accountId" text not null, "providerId" text not null, "userId" text not null references "user" ("id"), "accessToken" text, "refreshToken" text, "idToken" text, "accessTokenExpiresAt" timestamp, "refreshTokenExpiresAt" timestamp, "scope" text, "password" text, "createdAt" timestamp not null, "updatedAt" timestamp not null);

create table "verification" ("id" text not null primary key, "identifier" text not null, "value" text not null, "expiresAt" timestamp not null, "createdAt" timestamp, "updatedAt" timestamp);

-- ENUM para los tipos de categoría
CREATE TYPE public.category_type AS ENUM ('expense', 'income');

-- ENUM para los tipos de transacción
CREATE TYPE public.transaction_type AS ENUM ('expense', 'income', 'goal');

-- ENUM para el estado del historial de inicio de sesión
CREATE TYPE public.login_status AS ENUM ('success', 'failure');

-- ENUM para los estados de las metas
CREATE TYPE public.goal_states AS ENUM ('active', 'completed', 'archived');

-- app schemes
CREATE TABLE "profiles" (
  id TEXT NOT NULL PRIMARY KEY REFERENCES "user"(id) ON DELETE CASCADE,
  avatar_path TEXT,
  wallet NUMERIC(12, 2) NOT NULL DEFAULT 0,
  app_preferences JSON,
  failed_login_attempts INTEGER NOT NULL DEFAULT 0,
  lockout_expires_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.categories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id TEXT REFERENCES public.profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  icon_path TEXT NOT NULL,
  color TEXT NOT NULL,
  type public.category_type NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, name, type)
);

CREATE TABLE public.tags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id TEXT REFERENCES public.profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, name)
);

CREATE TABLE public.goals (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  goal_amount NUMERIC(12, 2) NOT NULL,
  saved_amount NUMERIC(12, 2) NOT NULL DEFAULT 0,
  icon_path TEXT,
  color TEXT NOT NULL,
  target_date DATE,
  state public.goal_states NOT NULL DEFAULT 'active',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  category_id BIGINT REFERENCES public.categories(id) ON DELETE SET NULL,
  goal_id BIGINT REFERENCES public.goals(id) ON DELETE SET NULL,
  type public.transaction_type NOT NULL,
  amount NUMERIC(12, 2) NOT NULL,
  description TEXT,
  tags BIGINT[],
  transaction_date TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.notification_templates (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  type TEXT NOT NULL UNIQUE,
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  action_url TEXT,
  metadata JSON,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.user_notifications (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  template_id BIGINT NOT NULL REFERENCES public.notification_templates(id) ON DELETE CASCADE,
  read_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.failed_login_attempts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  attempted_email TEXT NOT NULL,
  ip_address INET,
  user_agent TEXT,
  failure_reason TEXT,
  attempted_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Functions
CREATE OR REPLACE FUNCTION public.create_category(
  p_user_id TEXT,
  p_name TEXT,
  p_icon_path TEXT,
  p_color TEXT,
  p_type public.category_type
)
RETURNS public.categories
LANGUAGE plpgsql
AS $$
DECLARE
  new_category public.categories;
BEGIN
  INSERT INTO public.categories (user_id, name, icon_path, color, type)
  VALUES (p_user_id, p_name, p_icon_path, p_color, p_type)
  RETURNING * INTO new_category;
  RETURN new_category;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_user_categories(p_user_id TEXT)
RETURNS SETOF JSON
LANGUAGE sql STABLE AS $$
SELECT
  json_build_object(
    'id', c.id,
    'user_id', c.user_id,
    'name', c.name,
    'icon_path', c.icon_path,
    'color', c.color,
    'type', c.type,
    'created_at', c.created_at,
    'updated_at', c.updated_at,
    -- Datos anidados calculados:
    'stats', (
      SELECT json_build_object(
        'transaction_count', COUNT(t.id),
        'total_amount', COALESCE(SUM(t.amount), 0)
      )
      FROM public.transactions t
      WHERE t.category_id = c.id AND t.user_id = p_user_id
    )
  )
FROM
  public.categories AS c
WHERE
  c.user_id = p_user_id OR c.user_id IS NULL
ORDER BY
  c.user_id, c.name;
$$;

CREATE OR REPLACE FUNCTION public.update_category(
  p_category_id BIGINT,
  p_user_id TEXT,
  p_name TEXT,
  p_icon_path TEXT,
  p_color TEXT
)
RETURNS public.categories
LANGUAGE plpgsql
AS $$
DECLARE
  updated_category public.categories;
BEGIN
  UPDATE public.categories
  SET name = p_name, icon_path = p_icon_path, color = p_color, updated_at = now()
  WHERE id = p_category_id AND user_id = p_user_id
  RETURNING * INTO updated_category;
  RETURN updated_category;
END;
$$;

CREATE OR REPLACE FUNCTION public.delete_category(p_category_id BIGINT, p_user_id TEXT)
RETURNS public.categories
LANGUAGE plpgsql
AS $$
DECLARE
  deleted_category public.categories;
BEGIN
  DELETE FROM public.categories
  WHERE id = p_category_id AND user_id = p_user_id
  RETURNING * INTO deleted_category;
  RETURN deleted_category;
END;
$$;

CREATE OR REPLACE FUNCTION public.create_tag(p_user_id TEXT, p_name TEXT)
RETURNS public.tags
LANGUAGE plpgsql
AS $$
DECLARE
  new_tag public.tags;
BEGIN
  INSERT INTO public.tags (user_id, name)
  VALUES (p_user_id, p_name)
  RETURNING * INTO new_tag;
  RETURN new_tag;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_user_tags(p_user_id TEXT)
RETURNS SETOF JSON
LANGUAGE sql STABLE AS $$
SELECT
  json_build_object(
    'id', tg.id,
    'user_id', tg.user_id,
    'name', tg.name,
    'created_at', tg.created_at,
    'updated_at', tg.updated_at,
    -- Datos anidados calculados:
    'stats', (
      SELECT json_build_object(
        'transaction_count', COUNT(t.id),
        'total_amount', COALESCE(SUM(t.amount), 0)
      )
      FROM public.transactions t
      -- La condición cambia para buscar en el array de tags.
      WHERE tg.id = ANY(t.tags) AND t.user_id = p_user_id
    )
  )
FROM
  public.tags AS tg
WHERE
  tg.user_id = p_user_id OR tg.user_id IS NULL
ORDER BY
  tg.user_id, tg.name;
$$;

CREATE OR REPLACE FUNCTION public.update_tag(p_tag_id BIGINT, p_user_id TEXT, p_name TEXT)
RETURNS public.tags
LANGUAGE plpgsql
AS $$
DECLARE
  updated_tag public.tags;
BEGIN
  UPDATE public.tags SET name = p_name, updated_at = now()
  WHERE id = p_tag_id AND user_id = p_user_id
  RETURNING * INTO updated_tag;
  RETURN updated_tag;
END;
$$;

CREATE OR REPLACE FUNCTION public.delete_tag(p_tag_id BIGINT, p_user_id TEXT)
RETURNS public.tags
LANGUAGE plpgsql
AS $$
DECLARE
  deleted_tag public.tags;
BEGIN
  DELETE FROM public.tags
  WHERE id = p_tag_id AND user_id = p_user_id
  RETURNING * INTO deleted_tag;
  RETURN deleted_tag;
END;
$$;

CREATE OR REPLACE FUNCTION public.create_goal(
  p_user_id TEXT,
  p_name TEXT,
  p_goal_amount NUMERIC,
  p_icon_path TEXT,
  p_color TEXT,
  p_target_date DATE DEFAULT NULL
)
RETURNS public.goals
LANGUAGE plpgsql
AS $$
DECLARE
  new_goal public.goals;
BEGIN
  INSERT INTO public.goals (user_id, name, goal_amount, icon_path, color, target_date)
  VALUES (p_user_id, p_name, p_goal_amount, p_icon_path, p_color, p_target_date)
  RETURNING * INTO new_goal;
  
  RETURN new_goal;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_user_goals(p_user_id TEXT)
RETURNS SETOF JSON
LANGUAGE sql STABLE AS $$
SELECT
  json_build_object(
    'id', g.id,
    'user_id', g.user_id,
    'name', g.name,
    'goal_amount', g.goal_amount,
    'saved_amount', g.saved_amount,
    'icon_path', g.icon_path,
    'color', g.color,
    'target_date', g.target_date,
    'state', g.state,
    'created_at', g.created_at,
    'updated_at', g.updated_at,
    -- Dato anidado: Contar cuántas transacciones están asociadas a esta meta.
    'contribution_count', (
      SELECT COUNT(*)
      FROM public.transactions t
      WHERE t.goal_id = g.id
    )
  )
FROM
  public.goals AS g
WHERE
  g.user_id = p_user_id
ORDER BY
  g.created_at DESC;
$$;

CREATE OR REPLACE FUNCTION public.update_goal(
  p_goal_id BIGINT,
  p_user_id TEXT,
  p_name TEXT,
  p_goal_amount NUMERIC,
  p_icon_path TEXT, 
  p_color TEXT,  
  p_target_date DATE,
  p_state public.goal_states
)
RETURNS public.goals
LANGUAGE plpgsql
AS $$
DECLARE
  updated_goal public.goals;
BEGIN
  UPDATE public.goals
  SET 
    name = p_name, 
    goal_amount = p_goal_amount, 
    icon_path = p_icon_path,
    color = p_color,
    target_date = p_target_date, 
    state = p_state, 
    updated_at = now()
  WHERE 
    id = p_goal_id AND user_id = p_user_id
  RETURNING * INTO updated_goal;
  
  RETURN updated_goal;
END;
$$;

CREATE OR REPLACE FUNCTION public.delete_goal(p_goal_id BIGINT, p_user_id TEXT)
RETURNS public.goals
LANGUAGE plpgsql
AS $$
DECLARE
  deleted_goal public.goals;
BEGIN
  DELETE FROM public.goals WHERE id = p_goal_id AND user_id = p_user_id
  RETURNING * INTO deleted_goal;
  
  RETURN deleted_goal;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_or_create_tag_ids(p_user_id TEXT, p_tag_names TEXT[])
RETURNS BIGINT[]
LANGUAGE plpgsql
AS $$
DECLARE
  tag_ids BIGINT[] := ARRAY[]::BIGINT[];
  tag_name TEXT;
  tag_id BIGINT;
BEGIN
  FOREACH tag_name IN ARRAY p_tag_names
  LOOP
    SELECT id INTO tag_id FROM public.tags WHERE user_id = p_user_id AND name = tag_name;
    IF tag_id IS NULL THEN
      INSERT INTO public.tags (user_id, name) VALUES (p_user_id, tag_name) RETURNING id INTO tag_id;
    END IF;
    tag_ids := array_append(tag_ids, tag_id);
  END LOOP;
  RETURN tag_ids;
END;
$$;

CREATE OR REPLACE FUNCTION public.create_transaction(
  p_user_id TEXT,
  p_type public.transaction_type,
  p_amount NUMERIC,
  p_description TEXT,
  p_transaction_date TIMESTAMPTZ,
  p_category_id BIGINT DEFAULT NULL,
  p_goal_id BIGINT DEFAULT NULL,
  p_tag_names TEXT[] DEFAULT NULL
)
RETURNS public.transactions
LANGUAGE plpgsql
AS $$
DECLARE
  v_tag_ids BIGINT[];
  new_transaction public.transactions;
BEGIN
  IF p_tag_names IS NOT NULL AND array_length(p_tag_names, 1) > 0 THEN
    v_tag_ids := public.get_or_create_tag_ids(p_user_id, p_tag_names);
  END IF;

  INSERT INTO public.transactions (user_id, type, amount, description, transaction_date, category_id, goal_id, tags)
  VALUES (p_user_id, p_type, p_amount, p_description, p_transaction_date, p_category_id, p_goal_id, v_tag_ids)
  RETURNING * INTO new_transaction;
  RETURN new_transaction;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_transactions(
  p_user_id TEXT,
  p_start_date TIMESTAMPTZ,
  p_end_date TIMESTAMPTZ,
  p_limit INT DEFAULT 50,
  p_offset INT DEFAULT 0
)
RETURNS SETOF JSON
LANGUAGE sql STABLE AS $$
SELECT
  json_build_object(
    'id', t.id,
    'user_id', t.user_id,
    'type', t.type,
    'amount', t.amount,
    'description', t.description,
    'transaction_date', t.transaction_date,
    'created_at', t.created_at,
    'updated_at', t.updated_at,
    'category', (
      SELECT json_build_object(
        'id', c.id, 
        'name', c.name, 
        'icon_path', c.icon_path, 
        'color', c.color
      )
      FROM public.categories c
      WHERE c.id = t.category_id
    ),
    'goal', (
      SELECT json_build_object('id', g.id, 'name', g.name)
      FROM public.goals g
      WHERE g.id = t.goal_id
    ),
    'tags', COALESCE(
      (
        SELECT json_agg(
          json_build_object('id', tg.id, 'name', tg.name)
        )
        FROM public.tags tg
        WHERE tg.id = ANY(t.tags)
      ),
      '[]'::json
    )
  )
FROM
  public.transactions AS t
WHERE
  t.user_id = p_user_id
  AND t.transaction_date >= p_start_date
  AND t.transaction_date <= p_end_date
ORDER BY
  t.transaction_date DESC
LIMIT p_limit
OFFSET p_offset;
$$;


CREATE OR REPLACE FUNCTION public.update_transaction(
  p_transaction_id BIGINT,
  p_user_id TEXT,
  p_type public.transaction_type,
  p_amount NUMERIC,
  p_description TEXT,
  p_transaction_date TIMESTAMPTZ,
  p_category_id BIGINT,
  p_goal_id BIGINT,
  p_tag_names TEXT[]
)
RETURNS public.transactions
LANGUAGE plpgsql
AS $$
DECLARE
  v_tag_ids BIGINT[];
  updated_transaction public.transactions;
BEGIN
  IF p_tag_names IS NOT NULL AND array_length(p_tag_names, 1) > 0 THEN
    v_tag_ids := public.get_or_create_tag_ids(p_user_id, p_tag_names);
  ELSE
    v_tag_ids := ARRAY[]::BIGINT[];
  END IF;

  UPDATE public.transactions
  SET type=p_type, amount=p_amount, description=p_description, transaction_date=p_transaction_date,
      category_id=p_category_id, goal_id=p_goal_id, tags=v_tag_ids, updated_at=now()
  WHERE id = p_transaction_id AND user_id = p_user_id
  RETURNING * INTO updated_transaction;
  RETURN updated_transaction;
END;
$$;

CREATE OR REPLACE FUNCTION public.delete_transaction(
  p_transaction_id BIGINT,
  p_user_id TEXT
)
RETURNS public.transactions
LANGUAGE plpgsql
AS $$
DECLARE
  deleted_transaction public.transactions;
BEGIN
  DELETE FROM public.transactions
  WHERE id = p_transaction_id AND user_id = p_user_id
  RETURNING * INTO deleted_transaction;

  RETURN deleted_transaction;
END;
$$;

CREATE OR REPLACE FUNCTION public.check_goal_completion_status()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Solo actuar si el estado actual no es 'archivado'.
  IF OLD.state != 'archived' THEN
    -- Si el monto guardado alcanza o supera el objetivo
    IF NEW.saved_amount >= NEW.goal_amount THEN
      NEW.state := 'completed';
    -- Si estaba 'completada' pero ahora ya no (ej. se borró una contribución)
    ELSIF OLD.state = 'completed' AND NEW.saved_amount < NEW.goal_amount THEN
      NEW.state := 'active';
    END IF;
  END IF;
  -- Devuelve la fila modificada para que el UPDATE continúe.
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_profile_wallet()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    IF NEW.type = 'income' THEN
      UPDATE public.profiles SET wallet = wallet + NEW.amount WHERE id = NEW.user_id;
    ELSIF NEW.type = 'expense' OR NEW.type = 'goal' THEN
      UPDATE public.profiles SET wallet = wallet - NEW.amount WHERE id = NEW.user_id;
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN
    IF OLD.type = 'income' THEN
      UPDATE public.profiles SET wallet = wallet - OLD.amount WHERE id = OLD.user_id;
    ELSIF OLD.type = 'expense' OR OLD.type = 'goal' THEN
      UPDATE public.profiles SET wallet = wallet + OLD.amount WHERE id = OLD.user_id;
    END IF;

  ELSIF (TG_OP = 'UPDATE') THEN
    -- Paso 1: Revertir el valor ANTIGUO
    IF OLD.type = 'income' THEN
      UPDATE public.profiles SET wallet = wallet - OLD.amount WHERE id = OLD.user_id;
    ELSIF OLD.type = 'expense' OR OLD.type = 'goal' THEN
      UPDATE public.profiles SET wallet = wallet + OLD.amount WHERE id = OLD.user_id;
    END IF;
    -- Paso 2: Aplicar el valor NUEVO
    IF NEW.type = 'income' THEN
      UPDATE public.profiles SET wallet = wallet + NEW.amount WHERE id = NEW.user_id;
    ELSIF NEW.type = 'expense' OR NEW.type = 'goal' THEN
      UPDATE public.profiles SET wallet = wallet - NEW.amount WHERE id = NEW.user_id;
    END IF;
  END IF;

  IF (TG_OP = 'DELETE') THEN RETURN OLD; ELSE RETURN NEW; END IF;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_goal_saved_amount()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    IF NEW.type = 'goal' AND NEW.goal_id IS NOT NULL THEN
      UPDATE public.goals SET saved_amount = saved_amount + NEW.amount WHERE id = NEW.goal_id;
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN
    IF OLD.type = 'goal' AND OLD.goal_id IS NOT NULL THEN
      UPDATE public.goals SET saved_amount = saved_amount - OLD.amount WHERE id = OLD.goal_id;
    END IF;

  ELSIF (TG_OP = 'UPDATE') THEN
    -- Revertir el valor antiguo si era una contribución
    IF OLD.type = 'goal' AND OLD.goal_id IS NOT NULL THEN
      UPDATE public.goals SET saved_amount = saved_amount - OLD.amount WHERE id = OLD.goal_id;
    END IF;
    -- Aplicar el nuevo valor si AHORA es una contribución
    IF NEW.type = 'goal' AND NEW.goal_id IS NOT NULL THEN
      UPDATE public.goals SET saved_amount = saved_amount + NEW.amount WHERE id = NEW.goal_id;
    END IF;
  END IF;

  IF (TG_OP = 'DELETE') THEN RETURN OLD; ELSE RETURN NEW; END IF;
END;
$$;

-- Triggers
CREATE TRIGGER trg_check_goal_status_on_update
BEFORE UPDATE ON public.goals
FOR EACH ROW EXECUTE FUNCTION public.check_goal_completion_status();

CREATE TRIGGER trg_update_goal_on_transaction
AFTER INSERT OR UPDATE OR DELETE ON public.transactions
FOR EACH ROW EXECUTE FUNCTION public.update_goal_saved_amount();

CREATE TRIGGER trg_update_wallet_on_transaction
AFTER INSERT OR UPDATE OR DELETE ON public.transactions
FOR EACH ROW EXECUTE FUNCTION public.update_profile_wallet();
